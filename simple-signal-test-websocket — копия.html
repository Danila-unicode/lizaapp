<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç —Å–∏–≥–Ω–∞–ª–æ–≤ WebSocket</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        .user-section { border: 1px solid #ccc; padding: 20px; margin: 10px 0; }
        .log { background: #f5f5f5; padding: 10px; height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px; }
        button { padding: 10px 20px; margin: 5px; }
        input { padding: 5px; margin: 5px; }
        .success { color: green; }
        .error { color: red; }
        .warning { color: orange; }
        .info { color: blue; }
    </style>
</head>
<body>
    <div class="container">
        <h1>–ü—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç –æ–±–º–µ–Ω–∞ —Å–∏–≥–Ω–∞–ª–∞–º–∏ WebSocket</h1>
        <p><strong>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:</strong> –û—Ç–∫—Ä–æ–π—Ç–µ —ç—Ç—É —Å—Ç—Ä–∞–Ω–∏—Ü—É –≤ –¥–≤—É—Ö –≤–∫–ª–∞–¥–∫–∞—Ö –±—Ä–∞—É–∑–µ—Ä–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –º–µ–∂–¥—É –¥–≤—É–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏.</p>
        
        <div class="user-section">
            <h2>User 1</h2>
            <input type="text" id="user1Id" value="user1" placeholder="User ID">
            <button onclick="startUser1()">–ó–∞–ø—É—Å—Ç–∏—Ç—å User 1</button>
            <button onclick="sendPing1()">–û—Ç–ø—Ä–∞–≤–∏—Ç—å ping –∫ user2</button>
            <button onclick="resetUser1()" style="background: #ff9800; color: white;">üîÑ –°–±—Ä–æ—Å–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ</button>
            
        <div style="margin: 10px 0;">
            <button onclick="testOffer1()" id="offerBtn1" disabled style="background: #2196F3; color: white; display: none;">üìû –ù–∞—á–∞—Ç—å –∑–≤–æ–Ω–æ–∫</button>
            <button onclick="disconnectCall()" id="disconnectBtn1" disabled style="background: #f44336; color: white; display: none;">üîå –†–∞–∑–æ—Ä–≤–∞—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ</button>
        </div>
            
            <div style="display: flex; gap: 10px; margin: 10px 0;">
                <video id="localVideo1" autoplay muted style="width: 200px; height: 150px; border: 2px solid #4CAF50; background: #000;"></video>
                <video id="remoteVideo1" autoplay style="width: 200px; height: 150px; border: 2px solid #2196F3; background: #000;"></video>
            </div>
            
            <div id="log1" class="log"></div>
        </div>
        
        <div class="user-section">
            <h2>User 2</h2>
            <input type="text" id="user2Id" value="user2" placeholder="User ID">
            <button onclick="startUser2()">–ó–∞–ø—É—Å—Ç–∏—Ç—å User 2</button>
            <button onclick="sendPing2()">–û—Ç–ø—Ä–∞–≤–∏—Ç—å ping –∫ user1</button>
            <button onclick="resetUser2()" style="background: #ff9800; color: white;">üîÑ –°–±—Ä–æ—Å–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ</button>
            
        <div style="margin: 10px 0;">
            <button onclick="testAnswer2()" id="answerBtn2" disabled style="background: #4CAF50; color: white; display: none;">üì• –¢–µ—Å—Ç Answer (—Ä—É—á–Ω–æ–π)</button>
            <div id="autoAnswerInfo" style="display: none; color: #4CAF50; font-weight: bold;">ü§ñ Answer –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ offer</div>
        </div>
            
            <div style="display: flex; gap: 10px; margin: 10px 0;">
                <video id="localVideo2" autoplay muted style="width: 200px; height: 150px; border: 2px solid #4CAF50; background: #000;"></video>
                <video id="remoteVideo2" autoplay style="width: 200px; height: 150px; border: 2px solid #2196F3; background: #000;"></video>
            </div>
            
            <div id="log2" class="log"></div>
        </div>
        
        <div class="user-section">
            <h2>–ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–æ–≤</h2>
            <button onclick="copyAllLogs()" style="background: #4CAF50; color: white; font-weight: bold;">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –ª–æ–≥–∏</button>
            <p>–≠—Ç–∞ –∫–Ω–æ–ø–∫–∞ —Å–∫–æ–ø–∏—Ä—É–µ—Ç –ª–æ–≥–∏ –æ–±–æ–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫—É</p>
        </div>
    </div>

    <script>
        const SIGNALING_SERVER = 'https://lizamsg.ru:3000/api/signaling';
        
        // WebRTC –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { 
                    urls: 'turn:185.71.76.53:3478',
                    username: 'lizaapp',
                    credential: 'lizaapp123'
                },
                { 
                    urls: 'turns:185.71.76.53:3479',
                    username: 'lizaapp',
                    credential: 'lizaapp123'
                }
            ]
        };
        
        let user1 = {
            id: 'user1',
            lastSignalId: 0,
            interval: null,
            state: 'idle', // idle, connecting, connected, calling
            targetUser: null,
            peerConnection: null,
            localStream: null,
            isInitiator: false, // —Ñ–ª–∞–≥ –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            log: (msg, type = 'info') => {
                const logEl = document.getElementById('log1');
                const time = new Date().toLocaleTimeString();
                const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'info';
                logEl.innerHTML += `<div class="${className}">[${time}] ${msg}</div>`;
                logEl.scrollTop = logEl.scrollHeight;
            }
        };
        
        let user2 = {
            id: 'user2',
            lastSignalId: 0,
            interval: null,
            state: 'idle',
            targetUser: null,
            peerConnection: null,
            localStream: null,
            isInitiator: false, // —Ñ–ª–∞–≥ –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            log: (msg, type = 'info') => {
                const logEl = document.getElementById('log2');
                const time = new Date().toLocaleTimeString();
                const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'info';
                logEl.innerHTML += `<div class="${className}">[${time}] ${msg}</div>`;
                logEl.scrollTop = logEl.scrollHeight;
            }
        };
        
        // ===== USER 1 –§–£–ù–ö–¶–ò–ò =====
        
        async function startUser1() {
            user1.id = document.getElementById('user1Id').value;
            if (!user1.id) {
                user1.log('‚ùå –í–≤–µ–¥–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è 1', 'error');
                return;
            }
            
            user1.lastSignalId = Math.floor(Date.now() / 1000) - 60; // –ü–æ–ª—É—á–∞–µ–º —Å–∏–≥–Ω–∞–ª—ã –∑–∞ –ø–æ—Å–ª–µ–¥–Ω—é—é –º–∏–Ω—É—Ç—É
            user1.state = 'idle';
            user1.targetUser = null;
            user1.log(`üöÄ –ó–∞–ø—É—Å–∫ User 1: ${user1.id}`, 'success');
            user1.log(`‚è∞ –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã —Å—Ç–∞—Ä—à–µ: ${user1.lastSignalId}`, 'info');
            user1.log(`üìä –°–æ—Å—Ç–æ—è–Ω–∏–µ: ${user1.state}`, 'info');
            
            try {
                // –ü–æ–ª—É—á–∞–µ–º –º–µ–¥–∏–∞ –ø–æ—Ç–æ–∫–∏
                user1.localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });
                
                document.getElementById('localVideo1').srcObject = user1.localStream;
                user1.log('‚úÖ –ú–µ–¥–∏–∞ –ø–æ—Ç–æ–∫–∏ –ø–æ–ª—É—á–µ–Ω—ã', 'success');
                user1.log('üí° –ì–æ—Ç–æ–≤ –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ ping. –ù–∞–∂–º–∏—Ç–µ "–û—Ç–ø—Ä–∞–≤–∏—Ç—å ping –∫ user2"', 'info');
                
                // –ó–∞–ø—É—Å–∫–∞–µ–º polling –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤ (pong –æ—Ç user2)
                user1.interval = setInterval(() => checkSignals(user1), 1000);
                user1.log(`üîÑ –ó–∞–ø—É—â–µ–Ω polling –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤`, 'info');
                
            } catch (error) {
                user1.log(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ–¥–∏–∞: ${error.message}`, 'error');
            }
        }
        
        async function sendPing1() {
            if (user1.state !== 'idle') {
                user1.log(`‚ö†Ô∏è –ù–µ–ª—å–∑—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å ping - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user1.state}`, 'warning');
                return;
            }
            
            user1.state = 'connecting';
            user1.targetUser = user2.id;
            user1.isInitiator = true; // User1 –∏–Ω–∏—Ü–∏–∏—Ä—É–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
            user1.log(`üìä –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞: ${user1.state}`, 'info');
            user1.log(`üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ ping –∫ ${user2.id}`, 'warning');
            
            try {
                const response = await fetch(SIGNALING_SERVER, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'ping',
                        from: user1.id,
                        to: user2.id,
                        data: { timestamp: Date.now() }
                    })
                });
                
                const result = await response.json();
                user1.log(`üì° –û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞: ${JSON.stringify(result)}`, 'info');
                
                if (result.success) {
                    user1.log(`‚úÖ Ping –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ`, 'success');
                    // –ó–∞–ø—É—Å–∫–∞–µ–º polling –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è pong
                    user1.interval = setInterval(() => checkSignals(user1), 1000);
                    user1.log(`üîÑ –ó–∞–ø—É—â–µ–Ω polling –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è pong`, 'info');
                } else {
                    user1.log(`‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ ping: ${result.message}`, 'error');
                    user1.state = 'idle';
                }
            } catch (error) {
                user1.log(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`, 'error');
                user1.state = 'idle';
            }
        }
        
        async function testOffer1() {
            if (user1.state !== 'connected') {
                user1.log(`‚ö†Ô∏è –ù–µ–ª—å–∑—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å offer - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user1.state}`, 'warning');
                return;
            }
            
            user1.log('üîß –°–æ–∑–¥–∞–Ω–∏–µ Peer Connection...', 'info');
            
            try {
                // –°–æ–∑–¥–∞–µ–º Peer Connection
                user1.peerConnection = new RTCPeerConnection(rtcConfig);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫
                user1.localStream.getTracks().forEach(track => {
                    user1.peerConnection.addTrack(track, user1.localStream);
                });
                
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
                user1.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        user1.log('üßä ICE –∫–∞–Ω–¥–∏–¥–∞—Ç –Ω–∞–π–¥–µ–Ω', 'info');
                        sendSignal(user1, user2.id, 'ice-candidate', event.candidate);
                    }
                };
                
                user1.peerConnection.ontrack = (event) => {
                    user1.log('üìπ –ü–æ–ª—É—á–µ–Ω —É–¥–∞–ª–µ–Ω–Ω—ã–π –ø–æ—Ç–æ–∫', 'success');
                    document.getElementById('remoteVideo1').srcObject = event.streams[0];
                };
                
                // –°–æ–∑–¥–∞–µ–º offer
                const offer = await user1.peerConnection.createOffer();
                await user1.peerConnection.setLocalDescription(offer);
                
                user1.log('üì§ Offer —Å–æ–∑–¥–∞–Ω, –æ—Ç–ø—Ä–∞–≤–∫–∞...', 'info');
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º offer
                await sendSignal(user1, user2.id, 'offer', offer);
                
                user1.state = 'calling';
                user1.log(`üìä –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞: ${user1.state}`, 'info');
                document.getElementById('disconnectBtn1').style.display = 'inline-block';
                document.getElementById('disconnectBtn1').disabled = false;
                user1.log('‚úÖ Offer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω, –æ–∂–∏–¥–∞–Ω–∏–µ answer', 'success');
                
                // –ó–∞–ø—É—Å–∫–∞–µ–º polling –¥–ª—è WebRTC —Å–∏–≥–Ω–∞–ª–æ–≤ (answer)
                user1.interval = setInterval(() => checkWebRTCSignals(user1), 1000);
                user1.log(`üîÑ –ó–∞–ø—É—â–µ–Ω polling –¥–ª—è WebRTC —Å–∏–≥–Ω–∞–ª–æ–≤ (answer)`, 'info');
                
            } catch (error) {
                user1.log(`‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è offer: ${error.message}`, 'error');
                user1.state = 'idle';
            }
        }
        
        
        // ===== USER 2 –§–£–ù–ö–¶–ò–ò =====
        
        async function startUser2() {
            user2.id = document.getElementById('user2Id').value;
            if (!user2.id) {
                user2.log('‚ùå –í–≤–µ–¥–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è 2', 'error');
                return;
            }
            
            user2.lastSignalId = Math.floor(Date.now() / 1000) - 60; // –ü–æ–ª—É—á–∞–µ–º —Å–∏–≥–Ω–∞–ª—ã –∑–∞ –ø–æ—Å–ª–µ–¥–Ω—é—é –º–∏–Ω—É—Ç—É
            user2.state = 'idle';
            user2.targetUser = null;
            user2.log(`üöÄ –ó–∞–ø—É—Å–∫ User 2: ${user2.id}`, 'success');
            user2.log(`‚è∞ –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã —Å—Ç–∞—Ä—à–µ: ${user2.lastSignalId}`, 'info');
            user2.log(`üìä –°–æ—Å—Ç–æ—è–Ω–∏–µ: ${user2.state}`, 'info');
            
            try {
                // –ü–æ–ª—É—á–∞–µ–º –º–µ–¥–∏–∞ –ø–æ—Ç–æ–∫–∏
                user2.localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });
                
                document.getElementById('localVideo2').srcObject = user2.localStream;
                user2.log('‚úÖ –ú–µ–¥–∏–∞ –ø–æ—Ç–æ–∫–∏ –ø–æ–ª—É—á–µ–Ω—ã', 'success');
                user2.log('üí° –ì–æ—Ç–æ–≤ –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ ping. –ù–∞–∂–º–∏—Ç–µ "–û—Ç–ø—Ä–∞–≤–∏—Ç—å ping –∫ user1"', 'info');
                
                // –ó–∞–ø—É—Å–∫–∞–µ–º polling –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤ (ping –æ—Ç user1)
                user2.interval = setInterval(() => checkSignals(user2), 1000);
                user2.log(`üîÑ –ó–∞–ø—É—â–µ–Ω polling –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤`, 'info');
                
            } catch (error) {
                user2.log(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ–¥–∏–∞: ${error.message}`, 'error');
            }
        }
        
        async function sendPing2() {
            if (user2.state !== 'idle') {
                user2.log(`‚ö†Ô∏è –ù–µ–ª—å–∑—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å ping - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user2.state}`, 'warning');
                return;
            }
            
            user2.state = 'connecting';
            user2.targetUser = user1.id;
            user2.isInitiator = true; // User2 –∏–Ω–∏—Ü–∏–∏—Ä—É–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
            user2.log(`üìä –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞: ${user2.state}`, 'info');
            user2.log(`üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ ping –∫ ${user1.id}`, 'warning');
            
            try {
                const response = await fetch(SIGNALING_SERVER, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'ping',
                        from: user2.id,
                        to: user1.id,
                        data: { timestamp: Date.now() }
                    })
                });
                
                const result = await response.json();
                user2.log(`üì° –û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞: ${JSON.stringify(result)}`, 'info');
                
                if (result.success) {
                    user2.log(`‚úÖ Ping –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ`, 'success');
                    // –ó–∞–ø—É—Å–∫–∞–µ–º polling –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è pong
                    user2.interval = setInterval(() => checkSignals(user2), 1000);
                    user2.log(`üîÑ –ó–∞–ø—É—â–µ–Ω polling –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è pong`, 'info');
                } else {
                    user2.log(`‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ ping: ${result.message}`, 'error');
                    user2.state = 'idle';
                }
            } catch (error) {
                user2.log(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`, 'error');
                user2.state = 'idle';
            }
        }
        
        async function testAnswer2() {
            if (user2.state !== 'connecting') {
                user2.log(`‚ö†Ô∏è –ù–µ–ª—å–∑—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å answer - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user2.state}`, 'warning');
                return;
            }
            
            user2.log('üîß –°–æ–∑–¥–∞–Ω–∏–µ Peer Connection...', 'info');
            
            try {
                // –°–æ–∑–¥–∞–µ–º Peer Connection
                user2.peerConnection = new RTCPeerConnection(rtcConfig);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫
                user2.localStream.getTracks().forEach(track => {
                    user2.peerConnection.addTrack(track, user2.localStream);
                });
                
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
                user2.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        user2.log('üßä ICE –∫–∞–Ω–¥–∏–¥–∞—Ç –Ω–∞–π–¥–µ–Ω', 'info');
                        sendSignal(user2, user1.id, 'ice-candidate', event.candidate);
                    }
                };
                
                user2.peerConnection.ontrack = (event) => {
                    user2.log('üìπ –ü–æ–ª—É—á–µ–Ω —É–¥–∞–ª–µ–Ω–Ω—ã–π –ø–æ—Ç–æ–∫', 'success');
                    document.getElementById('remoteVideo2').srcObject = event.streams[0];
                };
                
                // –°–æ–∑–¥–∞–µ–º answer
                const answer = await user2.peerConnection.createAnswer();
                await user2.peerConnection.setLocalDescription(answer);
                
                user2.log('üì• Answer —Å–æ–∑–¥–∞–Ω, –æ—Ç–ø—Ä–∞–≤–∫–∞...', 'info');
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º answer
                await sendSignal(user2, user1.id, 'answer', answer);
                
                user2.state = 'calling';
                user2.log('‚úÖ Answer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω, —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ', 'success');
                
            } catch (error) {
                user2.log(`‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è answer: ${error.message}`, 'error');
                user2.state = 'idle';
            }
        }
        
        // ===== –û–ë–©–ò–ï –§–£–ù–ö–¶–ò–ò =====
        
        async function checkWebRTCSignals(user) {
            // –ó–∞—â–∏—Ç–∞ –æ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
            if (user.checkingWebRTCSignals) {
                return;
            }
            user.checkingWebRTCSignals = true;
            
            try {
                const url = `${SIGNALING_SERVER}?action=signals&userId=${user.id}&since=${user.lastSignalId}`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success && data.signals && data.signals.length > 0) {
                    const newSignals = data.signals.filter(signal => {
                        const signalTimestamp = signal.timestamp || signal.id;
                        return signalTimestamp > user.lastSignalId;
                    });
                    
                    if (newSignals.length > 0) {
                        newSignals.forEach(signal => {
                            user.lastSignalId = Math.max(user.lastSignalId, signal.timestamp || signal.id);
                            
                            if (signal.type === 'offer') {
                                user.log(`üì• –ü–æ–ª—É—á–µ–Ω offer –æ—Ç ${signal.from}`, 'warning');
                                handleOffer(user, signal);
                            } else if (signal.type === 'answer') {
                                user.log(`üì• –ü–æ–ª—É—á–µ–Ω answer –æ—Ç ${signal.from}`, 'warning');
                                handleAnswer(user, signal);
                            } else if (signal.type === 'ice-candidate') {
                                handleIceCandidate(user, signal);
                            }
                        });
                        
                        // –£–¥–∞–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã —Å —Å–µ—Ä–≤–µ—Ä–∞
                        await deleteProcessedSignals(user);
                    }
                }
            } catch (error) {
                user.log(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ WebRTC —Å–∏–≥–Ω–∞–ª–æ–≤: ${error.message}`, 'error');
            } finally {
                user.checkingWebRTCSignals = false;
            }
        }
        
        async function deleteProcessedSignals(user) {
            try {
                const url = `${SIGNALING_SERVER}?action=delete&userId=${user.id}`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success) {
                    user.log(`üóëÔ∏è –û–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã —É–¥–∞–ª–µ–Ω—ã —Å —Å–µ—Ä–≤–µ—Ä–∞`, 'info');
                }
            } catch (error) {
                user.log(`‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤: ${error.message}`, 'error');
            }
        }
        
        async function checkSignals(user) {
            // –ó–∞—â–∏—Ç–∞ –æ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
            if (user.checkingSignals) {
                return;
            }
            user.checkingSignals = true;
            
            try {
                const url = `${SIGNALING_SERVER}?action=signals&userId=${user.id}&since=${user.lastSignalId}`;
                user.log(`üîç –ó–∞–ø—Ä–æ—Å: ${url}`, 'info');
                
                const response = await fetch(url);
                const data = await response.json();
                
                user.log(`üì° –û—Ç–≤–µ—Ç: ${JSON.stringify(data)}`, 'info');
                
                if (data.success && data.signals && data.signals.length > 0) {
                    user.log(`üì® –ü–æ–ª—É—á–µ–Ω–æ ${data.signals.length} —Å–∏–≥–Ω–∞–ª–æ–≤`, 'success');
                    
                    // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ù–û–í–´–ï —Å–∏–≥–Ω–∞–ª—ã (–ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
                    const newSignals = data.signals.filter(signal => {
                        const signalTimestamp = signal.timestamp || signal.id;
                        const isNew = signalTimestamp > user.lastSignalId;
                        if (!isNew) {
                            user.log(`‚è∞ –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å—Ç–∞—Ä—ã–π —Å–∏–≥–Ω–∞–ª: ${signal.type} –æ—Ç ${signal.from} (timestamp: ${signalTimestamp} <= ${user.lastSignalId})`, 'warning');
                        }
                        return isNew;
                    });
                    
                    if (newSignals.length === 0) {
                        user.log(`üîç –í—Å–µ —Å–∏–≥–Ω–∞–ª—ã —Å—Ç–∞—Ä—ã–µ, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º`, 'info');
                        // –û–±–Ω–æ–≤–ª—è–µ–º lastSignalId –¥–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
                        const maxTimestamp = Math.max(...data.signals.map(s => s.timestamp || s.id));
                        user.lastSignalId = Math.max(user.lastSignalId, maxTimestamp);
                        return;
                    }
                    
                    user.log(`üì® –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º ${newSignals.length} –Ω–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤`, 'success');
                    
                    for (const signal of newSignals) {
                        user.lastSignalId = Math.max(user.lastSignalId, signal.timestamp || signal.id);
                        user.log(`üì® ${signal.type} –æ—Ç ${signal.from}`, 'success');
                        
                        if (signal.type === 'ping') {
                            if (user.state === 'idle') {
                                user.log(`üèì –ü–æ–ª—É—á–µ–Ω ping –æ—Ç ${signal.from} - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º pong`, 'warning');
                                user.state = 'connecting';
                                user.targetUser = signal.from;
                                user.log(`üìä –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞: ${user.state}`, 'info');
                                await sendSignal(user, signal.from, 'pong', { received: true });
                                // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ connected –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ pong
                                user.state = 'connected';
                                user.log(`üìä –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞: ${user.state}`, 'success');
                                user.log(`üîó P2P —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ –¥–ª—è WebRTC!`, 'success');
                                
                                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º polling –ø–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–≤—è–∑–∏
                                if (user.interval) {
                                    clearInterval(user.interval);
                                    user.interval = null;
                                    user.log(`‚èπÔ∏è Polling –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - —Å–≤—è–∑—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`, 'info');
                                }
                                
                                // –ó–∞–ø—É—Å–∫–∞–µ–º polling –¥–ª—è WebRTC —Å–∏–≥–Ω–∞–ª–æ–≤ (offer)
                                user.interval = setInterval(() => checkWebRTCSignals(user), 1000);
                                user.log(`üîÑ –ó–∞–ø—É—â–µ–Ω polling –¥–ª—è WebRTC —Å–∏–≥–Ω–∞–ª–æ–≤ (offer)`, 'info');
                                
                                updateCallButtons(user);
                            } else {
                                user.log(`‚ö†Ô∏è –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º ping –æ—Ç ${signal.from} - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user.state}`, 'warning');
                            }
                        } else if (signal.type === 'pong') {
                            user.log(`üèì –ü–æ–ª—É—á–µ–Ω pong –æ—Ç ${signal.from}`, 'info');
                            user.log(`üìä –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user.state}, –æ–∂–∏–¥–∞–µ–º –æ—Ç: ${user.targetUser}`, 'info');
                            user.log(`üìä isInitiator: ${user.isInitiator}`, 'info');
                            
                            if (user.state === 'connecting' && user.targetUser === signal.from) {
                                user.log(`üèì –ü–æ–ª—É—á–µ–Ω pong –æ—Ç ${signal.from} - —Å–≤—è–∑—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞!`, 'success');
                                user.state = 'connected';
                                user.log(`üìä –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞: ${user.state}`, 'success');
                                user.log(`üîó P2P —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ –¥–ª—è WebRTC!`, 'success');
                                user.log(`üí° –¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –Ω–∞–∂–∞—Ç—å "–ù–∞—á–∞—Ç—å –∑–≤–æ–Ω–æ–∫" –¥–ª—è WebRTC`, 'info');
                                
                                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º polling –ø–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–≤—è–∑–∏
                                if (user.interval) {
                                    clearInterval(user.interval);
                                    user.interval = null;
                                    user.log(`‚èπÔ∏è Polling –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - —Å–≤—è–∑—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`, 'info');
                                }
                                
                                // –ó–∞–ø—É—Å–∫–∞–µ–º polling –¥–ª—è WebRTC —Å–∏–≥–Ω–∞–ª–æ–≤ (offer)
                                user.interval = setInterval(() => checkWebRTCSignals(user), 1000);
                                user.log(`üîÑ –ó–∞–ø—É—â–µ–Ω polling –¥–ª—è WebRTC —Å–∏–≥–Ω–∞–ª–æ–≤ (offer)`, 'info');
                                
                                updateCallButtons(user);
                            } else if (user.state === 'connected' && user.targetUser === signal.from) {
                                user.log(`üèì –ü–æ–ª—É—á–µ–Ω pong –æ—Ç ${signal.from} - —Å–≤—è–∑—å —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`, 'info');
                            } else {
                                user.log(`‚ö†Ô∏è –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º pong –æ—Ç ${signal.from} - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user.state}, –æ–∂–∏–¥–∞–ª–∏: ${user.targetUser}`, 'warning');
                            }
                        } else if (signal.type === 'disconnect') {
                            handleDisconnect(user, signal);
                        }
                        // offer/answer/ice-candidate –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –≤ checkWebRTCSignals
                    }
                    
                    // –£–¥–∞–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã —Å —Å–µ—Ä–≤–µ—Ä–∞
                    await deleteProcessedSignals(user);
                } else {
                    user.log(`üîç –ù–µ—Ç –Ω–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤`, 'info');
                }
            } catch (error) {
                user.log(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: ${error.message}`, 'error');
            } finally {
                user.checkingSignals = false;
            }
        }
        
        function updateCallButtons(user) {
            if (user.id === 'user1') {
                const offerBtn = document.getElementById('offerBtn1');
                const disconnectBtn = document.getElementById('disconnectBtn1');
                if (user.state === 'connected' && user.isInitiator) {
                    offerBtn.style.display = 'inline-block';
                    offerBtn.disabled = false;
                    disconnectBtn.style.display = 'inline-block';
                    disconnectBtn.disabled = false;
                    user.log(`üîò –ö–Ω–æ–ø–∫–∞ "–ù–∞—á–∞—Ç—å –∑–≤–æ–Ω–æ–∫" –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–∞`, 'success');
                } else {
                    offerBtn.style.display = 'none';
                    disconnectBtn.style.display = 'none';
                }
            } else if (user.id === 'user2') {
                const autoAnswerInfo = document.getElementById('autoAnswerInfo');
                if (user.state === 'connected') {
                    autoAnswerInfo.style.display = 'block';
                } else {
                    autoAnswerInfo.style.display = 'none';
                }
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ WebRTC —Å–∏–≥–Ω–∞–ª–æ–≤
        async function handleOffer(user, signal) {
            if (user.state !== 'connected') {
                user.log(`‚ö†Ô∏è –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º offer - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user.state}`, 'warning');
                return;
            }

            user.log(`üì• –ü–æ–ª—É—á–µ–Ω offer –æ—Ç ${signal.from}`, 'warning');
            user.log(`üì• Offer –¥–∞–Ω–Ω—ã–µ: type=${signal.data.type}, sdp –¥–ª–∏–Ω–∞=${signal.data.sdp ? signal.data.sdp.length : 'undefined'}`, 'info');
            user.log(`üì• –°–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${user.state}`, 'info');
            
            try {
                // –°–æ–∑–¥–∞–µ–º PeerConnection –¥–ª—è User2
                if (!user.peerConnection) {
                    user.peerConnection = new RTCPeerConnection(rtcConfig);
                    user.log(`üîß PeerConnection —Å–æ–∑–¥–∞–Ω –¥–ª—è ${user.id}`, 'info');
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫
                    if (user.localStream) {
                        user.localStream.getTracks().forEach(track => {
                            user.peerConnection.addTrack(track, user.localStream);
                        });
                        user.log(`üìπ –õ–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫ –¥–æ–±–∞–≤–ª–µ–Ω –≤ PeerConnection`, 'info');
                    }
                    
                    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞
                    user.peerConnection.ontrack = (event) => {
                        user.log('üìπ –ü–æ–ª—É—á–µ–Ω —É–¥–∞–ª–µ–Ω–Ω—ã–π –ø–æ—Ç–æ–∫', 'success');
                        document.getElementById(`remoteVideo${user.id === 'user1' ? '1' : '2'}`).srcObject = event.streams[0];
                    };
                }
                
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–π offer
                await user.peerConnection.setRemoteDescription(new RTCSessionDescription(signal.data));
                user.log(`‚úÖ Offer —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ PeerConnection`, 'success');
                
                // –ó–∞–ø—É—Å–∫–∞–µ–º polling –¥–ª—è WebRTC —Å–∏–≥–Ω–∞–ª–æ–≤ (answer)
                user.interval = setInterval(() => checkWebRTCSignals(user), 1000);
                user.log(`üîÑ –ó–∞–ø—É—â–µ–Ω polling –¥–ª—è WebRTC —Å–∏–≥–Ω–∞–ª–æ–≤ (answer)`, 'info');
                
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º answer
                user.log(`üöÄ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º answer –∫ ${signal.from}`, 'warning');
                await sendTestAnswer(user, signal.from);
                
            } catch (error) {
                user.log(`‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ offer: ${error.message}`, 'error');
            }
        }
        
        function handleAnswer(user, signal) {
            if (user.state !== 'calling') {
                user.log(`‚ö†Ô∏è –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º answer - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user.state}`, 'warning');
                return;
            }

            user.log(`üì• –ü–æ–ª—É—á–µ–Ω answer –æ—Ç ${signal.from}`, 'warning');
            user.log(`üì• Answer –¥–∞–Ω–Ω—ã–µ: type=${signal.data.type}, sdp –¥–ª–∏–Ω–∞=${signal.data.sdp ? signal.data.sdp.length : 'undefined'}`, 'info');
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º answer –≤ PeerConnection
            if (user.peerConnection && signal.data.sdp) {
                user.peerConnection.setRemoteDescription(new RTCSessionDescription(signal.data))
                    .then(() => {
                        user.log(`‚úÖ Answer —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ PeerConnection`, 'success');
                        user.log(`‚úÖ Offer/Answer –æ–±–º–µ–Ω –∑–∞–≤–µ—Ä—à–µ–Ω!`, 'success');
                        user.log(`üîó P2P —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ!`, 'success');
                        user.log(`üìπ –í–∏–¥–µ–æ/–∞—É–¥–∏–æ –ø–æ—Ç–æ–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã`, 'success');
                    })
                    .catch(error => {
                        user.log(`‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ answer: ${error.message}`, 'error');
                    });
            } else {
                user.log(`‚ùå –ù–µ—Ç PeerConnection –∏–ª–∏ SDP –¥–∞–Ω–Ω—ã—Ö`, 'error');
            }
            
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º polling –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è answer
            if (user.interval) {
                clearInterval(user.interval);
                user.interval = null;
                user.log(`‚èπÔ∏è Polling –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ`, 'info');
            }
        }
        
        function handleIceCandidate(user, signal) {
            if (user.peerConnection && signal.data.candidate) {
                user.peerConnection.addIceCandidate(new RTCIceCandidate(signal.data))
                    .then(() => {
                        user.log(`üßä ICE –∫–∞–Ω–¥–∏–¥–∞—Ç –¥–æ–±–∞–≤–ª–µ–Ω –æ—Ç ${signal.from}`, 'success');
                    })
                    .catch(error => {
                        user.log(`‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è ICE –∫–∞–Ω–¥–∏–¥–∞—Ç–∞: ${error.message}`, 'error');
                    });
            } else {
                user.log(`üßä –ü–æ–ª—É—á–µ–Ω ICE –∫–∞–Ω–¥–∏–¥–∞—Ç –æ—Ç ${signal.from} (–Ω–µ—Ç PeerConnection)`, 'info');
            }
        }

        function handleDisconnect(user, signal) {
            if (user.state === 'connected' && user.targetUser === signal.from) {
                user.log(`üîå –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª —Ä–∞–∑—Ä—ã–≤–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –æ—Ç ${signal.from}`, 'warning');
                user.log(`üìä –ü—Ä–∏—á–∏–Ω–∞: ${signal.data.reason || '–Ω–µ —É–∫–∞–∑–∞–Ω–∞'}`, 'info');
                
                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                user.state = 'idle';
                user.targetUser = null;
                user.log(`üìä –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞: ${user.state}`, 'info');
                user.log(`üîÑ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ, –≤–æ–∑–≤—Ä–∞—Ç –≤ –∏—Å—Ö–æ–¥–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ`, 'success');
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏
                updateCallButtons(user);
            } else {
                user.log(`‚ö†Ô∏è –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º disconnect –æ—Ç ${signal.from} - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user.state}, –æ–∂–∏–¥–∞–ª–∏: ${user.targetUser}`, 'warning');
            }
        }
        
        // –û—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ–∞–ª—å–Ω–æ–≥–æ answer —á–µ—Ä–µ–∑ PeerConnection
        async function sendTestAnswer(user, toUserId) {
            const startTime = Date.now();
            try {
                user.log(`üì§ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ answer –∫ ${toUserId}`, 'warning');
                
                // –°–æ–∑–¥–∞–µ–º PeerConnection –¥–ª—è User2
                if (!user.peerConnection) {
                    user.peerConnection = new RTCPeerConnection(rtcConfig);
                    user.log(`üîß PeerConnection —Å–æ–∑–¥–∞–Ω –¥–ª—è ${user.id}`, 'info');
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫
                    if (user.localStream) {
                        user.localStream.getTracks().forEach(track => {
                            user.peerConnection.addTrack(track, user.localStream);
                        });
                        user.log(`üìπ –õ–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫ –¥–æ–±–∞–≤–ª–µ–Ω –≤ PeerConnection`, 'info');
                    }
                    
                    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞
                    user.peerConnection.ontrack = (event) => {
                        user.log('üìπ –ü–æ–ª—É—á–µ–Ω —É–¥–∞–ª–µ–Ω–Ω—ã–π –ø–æ—Ç–æ–∫', 'success');
                        document.getElementById(`remoteVideo${user.id === 'user1' ? '1' : '2'}`).srcObject = event.streams[0];
                    };
                }
                
                // –°–æ–∑–¥–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–π answer
                const answer = await user.peerConnection.createAnswer();
                await user.peerConnection.setLocalDescription(answer);
                
                user.log('üì• Answer —Å–æ–∑–¥–∞–Ω, –æ—Ç–ø—Ä–∞–≤–∫–∞...', 'info');
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∞–ª—å–Ω—ã–π answer
                const response = await fetch(SIGNALING_SERVER, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'signal',
                        from: user.id,
                        to: toUserId,
                        type: 'answer',
                        data: answer
                    })
                });

                const result = await response.json();
                const sendTime = Date.now() - startTime;
                if (result.success) {
                    user.log(`‚úÖ Answer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ (${sendTime}–º—Å)`, 'success');
                    
                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ calling –¥–ª—è user2
                    user.state = 'calling';
                    user.log(`üìä –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞: ${user.state}`, 'info');
                } else {
                    user.log(`‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ answer: ${result.error}`, 'error');
                }
            } catch (error) {
                user.log(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`, 'error');
            }
        }
        
        async function sendSignal(user, to, type, data) {
            try {
                user.log(`üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ ${type} –∫ ${to}`, 'warning');
                
                const response = await fetch(SIGNALING_SERVER, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'signal',
                        from: user.id,
                        to: to,
                        type: type,
                        data: data
                    })
                });
                
                const result = await response.json();
                user.log(`üì° –û—Ç–≤–µ—Ç: ${JSON.stringify(result)}`, 'info');
                
                if (result.success) {
                    user.log(`‚úÖ ${type} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ`, 'success');
                } else {
                    user.log(`‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: ${result.message}`, 'error');
                }
            } catch (error) {
                user.log(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`, 'error');
            }
        }
        
        function resetUser1() {
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º polling
            if (user1.interval) {
                clearInterval(user1.interval);
                user1.interval = null;
            }
            
            if (user1.peerConnection) {
                user1.peerConnection.close();
                user1.peerConnection = null;
            }
            
            if (user1.localStream) {
                user1.localStream.getTracks().forEach(track => track.stop());
                user1.localStream = null;
            }
            
            user1.state = 'idle';
            user1.targetUser = null;
            user1.isInitiator = false;
            
            document.getElementById('offerBtn1').style.display = 'none';
            document.getElementById('offerBtn1').disabled = true;
            document.getElementById('disconnectBtn1').style.display = 'none';
            document.getElementById('disconnectBtn1').disabled = true;
            
            document.getElementById('localVideo1').srcObject = null;
            document.getElementById('remoteVideo1').srcObject = null;
            
            user1.log('üîÑ User 1 —Å–±—Ä–æ—à–µ–Ω', 'warning');
        }
        
        function resetUser2() {
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º polling
            if (user2.interval) {
                clearInterval(user2.interval);
                user2.interval = null;
            }
            
            if (user2.peerConnection) {
                user2.peerConnection.close();
                user2.peerConnection = null;
            }
            
            if (user2.localStream) {
                user2.localStream.getTracks().forEach(track => track.stop());
                user2.localStream = null;
            }
            
            user2.state = 'idle';
            user2.targetUser = null;
            user2.isInitiator = false;
            
            document.getElementById('answerBtn2').style.display = 'none';
            document.getElementById('answerBtn2').disabled = true;
            
            document.getElementById('localVideo2').srcObject = null;
            document.getElementById('remoteVideo2').srcObject = null;
            
            user2.log('üîÑ User 2 —Å–±—Ä–æ—à–µ–Ω', 'warning');
        }
        
        async function disconnectCall() {
            // –û—á–∏—â–∞–µ–º —Å–∏–≥–Ω–∞–ª—ã –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ –¥–ª—è –æ–±–æ–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            try {
                user1.log('üßπ –û—á–∏—Å—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ...', 'info');
                
                // –û—á–∏—â–∞–µ–º —Å–∏–≥–Ω–∞–ª—ã –¥–ª—è user1
                const response1 = await fetch(`${SIGNALING_SERVER}?action=delete&userId=user1`);
                const result1 = await response1.json();
                user1.log(`üì° –û—á–∏—Å—Ç–∫–∞ user1: ${JSON.stringify(result1)}`, 'info');
                
                // –û—á–∏—â–∞–µ–º —Å–∏–≥–Ω–∞–ª—ã –¥–ª—è user2
                const response2 = await fetch(`${SIGNALING_SERVER}?action=delete&userId=user2`);
                const result2 = await response2.json();
                user2.log(`üì° –û—á–∏—Å—Ç–∫–∞ user2: ${JSON.stringify(result2)}`, 'info');
                
                user1.log('‚úÖ –í—Å–µ —Å–∏–≥–Ω–∞–ª—ã –æ—á–∏—â–µ–Ω—ã –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ', 'success');
                user2.log('‚úÖ –í—Å–µ —Å–∏–≥–Ω–∞–ª—ã –æ—á–∏—â–µ–Ω—ã –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ', 'success');
            } catch (error) {
                user1.log(`‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤: ${error.message}`, 'error');
                user2.log(`‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤: ${error.message}`, 'error');
            }
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            resetUser1();
            resetUser2();
        }
        
        function copyAllLogs() {
            const log1 = document.getElementById('log1').innerText;
            const log2 = document.getElementById('log2').innerText;
            const allLogs = `=== –õ–û–ì–ò USER 1 ===\n${log1}\n\n=== –õ–û–ì–ò USER 2 ===\n${log2}\n\n=== –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –¢–ï–°–¢–ï ===\n–í—Ä–µ–º—è —Ç–µ—Å—Ç–∞: ${new Date().toLocaleString()}\n–°–µ—Ä–≤–µ—Ä: ${SIGNALING_SERVER}\nUser 1 ID: ${user1.id}\nUser 2 ID: ${user2.id}`;
            
            navigator.clipboard.writeText(allLogs).then(() => {
                alert('–õ–æ–≥–∏ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞!');
            });
        }
    </script>
</body>
</html>
